<!DOCTYPE HTML>
<html lang="de">
<head>
<title>NumPut() - Syntax &amp; Verwendung | AutoHotkey</title>
<meta name="description" content="Die NumPut-Funktion speichert eine binäre Nummer auf eine bestimmte Adresse + Offset." />
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="../static/theme.css" rel="stylesheet" type="text/css" />
<script src="../static/content.js" type="text/javascript"></script>
<script src="../static/ga4.js" type="text/javascript"></script>
</head>
<body>

<h1>NumPut()</h1>
<p>Speichert eine binäre Nummer auf eine bestimmte Adresse + Offset.</p>
<pre class="Syntax"><span class="func">NumPut</span>(Nummer, VarOderAdresse <span class="optional">, Offset := 0</span><span class="optional">, Typ := "UPtr"</span>)</pre>

<h2 id="Parameters">Parameter</h2>
<dl>

  <dt>Nummer</dt>
  <dd><p>Die zu speichernde Nummer.</p></dd>

  <dt>VarOderAdresse</dt>
  <dd>
		<p>Eine Speicheradresse oder Variable. Wenn <em>VarOderAdresse</em> eine Variable wie <code>MeineVar</code> ist, wird die Adresse des Zeichenkettenpuffers der Variable verwendet. Im Prinzip ist dies das gleiche wie, als würde man <code>&amp;MeineVar</code> übergeben, allerdings wird durch Weglassen von "&amp;" eine bessere Leistung erzielt und sichergestellt, dass die Zieladresse + Offset <a href="VarSetCapacity.htm">gültig</a> ist.</p>
		<p><strong>Übergeben Sie keine Variablenreferenz</strong>, wenn die Variable die Zieladresse <em>enthält</em>; übergeben Sie in diesem Fall einen Ausdruck wie <code>MeineVar+0</code>.</p>
	</dd>

  <dt>Offset</dt>
  <dd><p>Eine Zahl (in Bytes), die mit <em>VarOderAdresse</em> addiert wird, um die Zieladresse zu bestimmen.</p></dd>

  <dt>Typ</dt>
  <dd>
    <p>Wenn dieser Parameter weggelassen wird oder leer ist, wird standardmäßig UPtr verwendet. Ansonsten können Sie UInt, UInt64, Int, Int64, Short, UShort, Char, UChar, Double, Float, Ptr oder UPtr angeben.</p>
    <p>UInt64 wird in <span class="ver">[v1.0.48+]</span> unterstützt, da große vorzeichenlose Werte als Zeichenketten übergeben werden können. In früheren Versionen und bei allen anderen Integer-Typen, oder bei der Übergabe von reinen Integern, hat der Unterschied zwischen vorzeichenfähig und vorzeichenlos keinen Einfluss auf das Ergebnis, weil zum Darstellen von vorzeichenfähigen Integern das Zweierkomplement genutzt wird.</p>
    <p>Diese Typen müssen, im Gegensatz zu den Typen von DllCall(), in Anführungszeichen gesetzt werden, wenn sie direkt geschriebene Zeichenketten sein sollen.</p>
    <p>Um mehr darüber zu erfahren, siehe <a href="DllCall.htm#types">DllCall-Typen</a>.</p>
  </dd>

</dl>

<h2 id="Return_Value">Rückgabewert</h2>
<p>Ist die Zieladresse ungültig, wird eine leere Zeichenkette zurückgegeben. Allerdings ist es möglich, dass einige ungültige Adressen nicht als solches erkannt werden, was zu unvorhersehbaren Verhalten führen könnte.</p>
<p>Ansonsten wird die Adresse ganz rechts des gerade geschriebenen Elements zurückgegeben. Dieser Rückgabewert wird häufig verwendet, wenn eine Folge von Nummern unterschiedlichen Typs geschrieben wird, wie in einer Struktur für DllCall().</p>

<h2 id="General_Remarks">Allgemeine Bemerkungen</h2>
<p>Überschreitet ein Integer den Gültigkeitsbereich des angegebenen <em>Typ</em>s, werden seine höchstwertigen Bytes ignoriert; z. B. würde <code>NumPut(257, Var, 0, "Char")</code> nur die Zahl 1 speichern.</p>
<p>Sind nur drei Parameter vorhanden, kann der dritte Parameter entweder <em>Offset</em> oder <em>Typ</em> sein. Zum Beispiel wäre <code>NumPut(x, var, "int")</code> gültig.</p>

<h2 id="Related">Siehe auch</h2>
<p><a href="NumGet.htm">NumGet()</a>, <a href="DllCall.htm">DllCall()</a>, <a href="VarSetCapacity.htm">VarSetCapacity()</a></p>


</body>
</html>
